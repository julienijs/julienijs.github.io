<!DOCTYPE html>
<html>
  <head>
    <title>Research | Julie Nijs</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/style.css">
  </head>
  <body>
    <header id="header"></header>
    <script src="js/header.js"></script>
    <main>
      
      <button onclick="topFunction()" id="TopBtn" title="Go to top">&lt;</button>

      <section class="project">
        <div class="projectText">
          <h2>The predictability of language change</h2>
          <p>It is most likely impossible to foresee when and where a particular language change will emerge (actuation problem), but the propagation of a language change is not haphazard. Rather, it follows an S-cure through time, that is best modelled by the logistic equation. We can conclude that a change is real when the residuals of the logistic curve (the difference between the observed and predicted values) are small. In this project we take a closer look at these residuals and ask the following questions:</p>
          <ol>
            <li>Are S-curves robust enough to be used for prediction and forecasting?</li>
            <li>Which variables will make the (standardized) residuals larger in the positive or negative direction in case of an ongoing change?</li>
          </ol>
          <p>In order to answer these questions we have build different models for 15 known binary language changes (new vs old variant), with the change (new or old variant) as the dependent variable and the decade (total of 15 decades) as the independent variable. For each change there are four models: one with all the data and three other models, each with some part of the data left out (first 5 decades, middle 5 decades or last 5 decades) to create a sliding window effect. We compare the residuals of these 3 partly blinded models to the residuals of the model with all the data to see how well the blind models are able to predict the missing decades.</p>
        </div>

        <img class="projectImage" src="images/predictability.png" alt="graf 2">

        <form action="https://github.com/nysju/Predictability-of-language-change" target="_blank">
          <button type="submit">Github</button>
        </form>

      </section>

      <section class="project">
        <div class="projectText">
          <h2>Language complexity</h2>
          <p>This project relies on Kolmogorov complexity to compare the morphological and syntactic complexity of three West-Germanic languages: Dutch, English and German. Kolmogorov complexity defines the complexity of a text as the length of the shortest possible description of this text. Kolmogorov complexity can be approximated by compression algorithms, such as gzip. The idea is then that a text which can be more easiliy compressed by a compression algorithm is linguistically less complex.</p>
          <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
          <p>Morphological distortion is achieved by randomly deleting 10% of all characters in a file. This operation leads to a higher amount of unique strings than before distortion and thus worse compressibility. A text with relatively high morphological complexity exhibits a relatively high amount of unique strings even before distortion. Its compressibility therefore is comparatively less affected by distortion than that of a text with relatively low morphological complexity and a relatively low amount of unique strings. The morphological complexity ratio is calculated as follow:

            $$ {- \frac{compressed\ file\ size\ after\ morphological\ distortion} {compressed\ file\ size\ before\ distortion}}$$ 
          </p>
          <p>Syntactic distortion is achieved by randomly deleting 10% of all tokens in a file. This operation disrupts the word order rules and leads to a higher amount of unique strings and comparatively worse compressibility than before distortion. Complex languages with strict word order rules will be more affected because of their high level of structural surface redundancies. Languages with free word order and a therefore low number of redundancies will be less affected. The syntactic complexity ratio or the word order rigidity ratio is calculated as follows:

            $$ {\frac{compressed\ file\ size\ after\ syntactic\ distortion} {compressed\ file\ size\ before\ distortion}}$$
          </p>
        </div>

        <img class="projectImage" src="images/complexity.png" alt="graf 2">

        <form action="https://github.com/nysju/Linguistic-complexity" target="_blank">
          <button type="submit">Github</button>
        </form>
      </section>

      <section class="project">
        <div class="projectText">
          <h2>The speed of language change</h2>
          <p>coming soon!</p>
        </div>

        <form action="https://github.com/nysju/Speed-of-language-change-and-population" target="_blank">
          <button type="submit">Github</button>
        </form>
      </section>
      
      <section class="project">
        <div class="projectText">
          <h2>Dutch V1 conditionals</h2>
          <p>coming soon!</p>
        </div>

        <form action="#" target="_blank">
          <button type="submit">Github</button>
        </form>
      </section>

      <script>
        /* Foto View */
const lightbox = document.createElement('div')
lightbox.id = 'lightbox'
document.body.appendChild(lightbox)

const images = document.querySelectorAll('img')
images.forEach(image => {
    image.addEventListener('click', e => {
        lightbox.classList.add('active')
        const img = document.createElement('img')
        img.src = image.src
        while (lightbox.firstChild) {
            lightbox.removeChild(lightbox.firstChild)
        }
        lightbox.appendChild(img)
    })
})

lightbox.addEventListener('click', e => {
    if (e.target !== e.currentTarget) return
    lightbox.classList.remove('active')
})


/* Go To Top Knop */
mybutton = document.getElementById("TopBtn");

window.onscroll = function () { scrollFunction() };
function scrollFunction() {
    if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
        mybutton.style.display = "block";
    } else {
        mybutton.style.display = "none";
    }
}

function topFunction() {
    document.body.scrollTop = 0; // voor Safari
    document.documentElement.scrollTop = 0; // voor Chrome, Firefox, IE en Opera
}


      </script>
      <style>
        /* Vergroote foto */
#lightbox {
    position: fixed;
    z-index: 1000;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: none;
}

#lightbox.active {
    display: flex;
    justify-content: center;
    align-items: center;
}

#lightbox img {
    max-width: 90%;
    max-height: 80%;
    padding: 4px;
    background-color: #000000;
    border: 2px solid #ffffff;
}


        /* Naar boven knop */
#TopBtn {
    display: block;
    position: fixed;
    bottom: 20px;
    right: 35px;
    z-index: 99;
    background-color: #2e2e2e;
    color: #ffffff;
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 15px;
    border: 2px solid #ffffff;
    font-size: 35px;
    transform: rotate(90deg);
}

#TopBtn:hover {
    background-color: #9e021a;
    animation: shake 0.2s;
}

@keyframes shake {
    0% { transform: translate(1px, 1px) rotate(90deg); }
    20% { transform: translate(-1px, -2px) rotate(89deg); }
    40% { transform: translate(-3px, 0px) rotate(91deg); }
    60% { transform: translate(3px, 2px) rotate(90deg); }
    80% { transform: translate(1px, -1px) rotate(91deg); }
    100% { transform: translate(1px, 1px) rotate(90deg); }
}
      </style>
    </main>
  </body>
</html>
